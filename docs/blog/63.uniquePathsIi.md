# [63] Unique Paths II

这题比`62. Unique Paths`的难点在于多了一个障碍物的概念。

既然有障碍物的地点不能走，那么到达障碍物格的可能性为0，直接将该格置为0。自然其右或是其下的格子的情况不能加上障碍物格的可能性种类(加了也是加0)，其他的解题思路不变。

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
  const m = obstacleGrid.length;
  const n = obstacleGrid[0].length;
  const dp = new Array(n).fill(0);
  for (let j = 0; j < n; j++) {
    if (obstacleGrid[0][j] === 1) break;
    dp[j] = 1;
  }
  for (let i = 1; i < m; i++) {
    let left = 0;
    for (let j = 0; j < n; j++) {
      if (obstacleGrid[i][j] === 1) {
        left = 0;
        dp[j] = 0;
      } else {
        left = dp[j] + left;
        dp[j] = left;
      }
    }
  }
  return dp[n - 1];
};
```

当然这里为了避免第一列有障碍物的情况，初始化了第一列整列。我们可以简化这一点，只需要每次判断当前遍历位置所在列不为0即可。

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
  if (!obstacleGrid || obstacleGrid.length === 0 || obstacleGrid[0].length === 0) return 0;
  const n = obstacleGrid.length;
  const m = obstacleGrid[0].length;

  const dp = new Array(m).fill(0);
  dp[0] = 1;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (obstacleGrid[i][j] === 1) dp[j] = 0;
      else if (j > 0) dp[j] = dp[j - 1] + dp[j];
    }
  }
  return dp[m - 1];
};
```
