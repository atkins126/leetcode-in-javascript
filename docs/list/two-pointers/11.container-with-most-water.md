# [11] 盛最多水的容器

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 说明：你不能倾斜容器。
>
> 示例 1：
>
> 输入：[1,8,6,2,5,4,8,3,7]
>
> 输出：49
>
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
>
> 示例 2：
>
> 输入：height = [1,1]
>
> 输出：1
>
> 示例 3：
>
> 输入：height = [4,3,2,1,4]
>
> 输出：16
>
> 示例 4：
>
> 输入：height = [1,2,1]
>
> 输出：2
>
> 提示：
>
> n == height.length
>
> 2 <= n <= 10^5
>
> 0 <= height[i] <= 10^4

这道题挺有意思的，它要求我们找出来存最多水的情况，指引我们用贪心法去解。

首先，基础用例是很好求出来的，面积 = 较短边高度 * 指针距离。我们先求出距离最远的两边盛水面积。

之后移动较短边的指针，为什么呢？因为若想找到更大的`面积`，在`指针距离`缩短的情况下，只有找到一条更长的边，来增加`较短边高度`才有可能实现。

不断比对当前盛水面积与记录的盛水面积，取较大值。直到左右指针重合，搜索结束。

```ts
function maxArea(height: number[]): number {
  let res = 0;

  let left = 0;
  let right = height.length - 1;
  while (left < right) {
    // 面积 = 短边高度 * 指针距离
    const temp = Math.min(height[left], height[right]) * (right - left);
    res = Math.max(res, temp);
    // 这里注意，要移动较短边的指针，才有可能找到更大值的情况
    if (height[left] < height[right]) {
      left += 1;
    } else {
      right -= 1;
    }
  }
  return res;
}
```
