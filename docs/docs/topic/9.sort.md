# 排序算法

一说到算法，第一个想到的一定是排序算法。是最经典，使用最广泛的算法，掌握几种快速算法的思路是很有必要的。

## 归并排序

归并排序采用的是分治法的思路，先分割子问题，再自底向上地对数组进行排序。

整个算法划分为两步，分割与治理。

分指将每一次的数组进行二分，并递归地分别进行排序。直到分到左指针等于右指针(left = right)，即子数组元素个数为1。

治指将两个有序子数组合并为一个有序数组。利用双指针技巧，不断地比较左右指针指向数据的大小，并将较小的那个进入排序数组。由于这里需要将两个数组合并为一个数组，因此并不能原地合并，需要新建一个辅助数组来完成有序数组的归并，完成后再赋值回原位置。

由于整体的思路是先分后治，因此该算法在递归形式上与二叉树的后序遍历是相似的。

```ts
function sortArray(nums: number[]): number[] {
  sort(0, nums.length - 1);
  return nums;

  function sort(left: number, right: number) {
    if (left === right) {
      // 单个元素不用排序
      return;
    }
    const mid = Math.floor((left + right) / 2);
    sort(left, mid);
    sort(mid + 1, right);
    merge(left, mid, right);
  }

  function merge(left: number, mid: number, right: number) {
    const temp = [];
    let l = left;
    let r = mid + 1;
    while (l < mid + 1 || r < right + 1) {
      if (l === mid + 1) {
        // 左侧数组已经全部合并，则将右边剩余数组直接拼接下来
        temp.push(nums[r]);
        r += 1;
      } else if (r === right + 1) {
        // 右侧数组已经全部合并，则将左边剩余数组直接拼接下来
        temp.push(nums[l]);
        l += 1;
      } else if (nums[l] > nums[r]) {
        // 左右指针两数相比取较小值，并前进指针
        temp.push(nums[r]);
        r += 1;
      } else {
        // temp[l] <= temp[r]
        temp.push(nums[l]);
        l += 1;
      }
    }
    // 原地更新数组
    for (let i = left; i <= right; i++) {
      nums[i] = temp[i - left];
    }
  }
}
```