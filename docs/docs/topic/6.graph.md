# 图遍历算法

图遍历算法，本质上就是一个更泛的树遍历算法。其遍历本质其实还是递归与回溯。

图的数据结构表示形式多以`邻接表`和`邻接矩阵`为主，这样能比较清晰的表示图中节点的连接关系。

`邻接表`的表示形式多以二维数组或数组对象为主，主要是表现对于每一个节点，其相邻的节点有哪些。

`邻接矩阵`的表现形式为二维数组。横纵轴分别为每个节点，单元格中的值为从节点 A 至节点 B 的权重。

## 有向无环图的遍历

无环图的特点在于不需要判断当前节点是否被访问过，可以节省一个数组空间。

这种题型的遍历方式与多叉树的遍历十分相似，都是递归其所有子节点。

这类题型基本上都是需要达到目标点时的路径，因此需要维护一个 path 数组来记录每一次经过的节点。

与回溯法类似，每消费完当前节点后，一定要记得将当前节点从选择路径中去除，来撤销当前选择，便于下一个递归函数继承 path。

这类题型典型代表是 `[797] 所有可能的路径`。

```ts
  // 结果数组
  const res: number[][] = [];
  // 记录已遍历过的路径
  const path: number[] = [];

  traverse(root);
  return res;

  function traverse(curr: Node) {
    // 添加当前节点到路径中
    path.push(curr);

    // 遍历到达终点
    if (curr 到达目标点) {
      // 拷贝一份当前路径，将其添加到结果数组中
      res.push([...path]);
      // 从路径中移除当前节点，相当于回溯法中的撤销选择
      path.pop();
      return;
    }

    // 递归所有相邻节点
    for (const adjacent of graph[curr]) {
      traverse(adjacent);
    }

    // 从路径中移除当前节点，相当于回溯法中的撤销选择
    path.pop();
  }
```
