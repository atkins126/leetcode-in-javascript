# 图遍历算法

图遍历算法，本质上就是一个更泛的树遍历算法。其遍历本质其实还是递归与回溯。

图的数据结构表示形式多以`邻接表`和`邻接矩阵`为主，这样能比较清晰的表示图中节点的连接关系。

`邻接表`的表示形式多以二维数组或集合（Set）数组为主，主要是表现对于每一个节点，其相邻的节点有哪些。数组形式也能表明对于每一个元素，其所对应的出度是什么。

`邻接矩阵`的表现形式为二维数组。横纵轴分别为每个节点，单元格中的值为从节点 A 至节点 B 的权重。

## 有向无环图(DAG)的遍历

无环图的特点在于不需要判断当前节点是否被访问过，可以节省一个 visited 的数组空间。

这种题型的遍历方式与多叉树的遍历十分相似，都是递归其所有子节点。

这类题型基本上都是需要达到目标点时的路径，因此需要维护一个 path 数组来记录每一次经过的节点。

与回溯法类似，每消费完当前节点后，一定要记得将当前节点从选择路径中去除，来撤销当前选择，便于下一个递归函数继承 path。

这类题型典型代表是 `[797] 所有可能的路径`。

```ts
  // 结果数组
  const res: number[][] = [];
  // 记录已遍历过的路径
  const path: number[] = [];

  traverse(root);
  return res;

  function traverse(curr: Node) {
    // 添加当前节点到路径中
    path.push(curr);

    // 遍历到达终点
    if (curr 到达目标点) {
      // 拷贝一份当前路径，将其添加到结果数组中
      res.push([...path]);
      // 从路径中移除当前节点，相当于回溯法中的撤销选择
      path.pop();
      return;
    }

    // 递归所有相邻节点
    for (const adjacent of graph[curr]) {
      traverse(adjacent);
    }

    // 从路径中移除当前节点，相当于回溯法中的撤销选择
    path.pop();
  }
```

题型参考：

1. `[797] 所有可能的路径`

## 图的成环检测

那么，如果不确定图是否是一个 DAG，那么该如何进行检测呢？

我们只需要再多维护一个 visited 数组，记录下每个已遍历过的节点。

```ts
  const visited: boolean[] = [];
  const onPath: boolean[] = [];

  // 此处是图的邻接表
  const graph: Set<number>[];

  let hasCycle = false;
  // 从每个节点为起点，开始进行遍历，保证每一个节点都被遍历到
  for (let i = 0; i < numCourses; i++) {
    traverse(i);
  }

  return !hasCycle;

  function traverse(index: number) {
    // 当前路径中的节点被再一次访问到了，说明出现了环
    if (onPath[index]) {
      hasCycle = true;
      // 已经发现环，则直接退出
      return;
    }

    // 若已经遍历过该节点，则剪枝
    if (visited[index]) {
      return;
    }

    // 做选择
    visited[index] = true;
    onPath[index] = true;
    // 递归遍历子节点
    for (const childIndex of graph[index]) {
      traverse(childIndex);
    }
    // 撤销选择
    onPath[index] = false;
  }
```

题型参考：

1. `[207] 课程表`

## 拓扑排序

拓扑排序.

注意，有环图是无法进行拓扑排序的。因此若不确定图无环，在进行拓扑排序前，需要先进行一次环检测算法。

拓扑排序其实就是图的后序遍历结果。因此与图的遍历方式密切相关。

```ts
  const res = [];
  traverse(root);
  return res;

  function traverse(curr: Node) {
    // 添加当前节点到路径中
    path.push(curr);

    // 遍历到达终点
    if (curr 到达目标点) {
      // 拷贝一份当前路径，将其添加到结果数组中
      res.push([...path]);
      // 从路径中移除当前节点，相当于回溯法中的撤销选择
      path.pop();
      return;
    }

    // 递归所有相邻节点
    for (const adjacent of graph[curr]) {
      traverse(adjacent);
    }
    // 后序遍历位置，记录当前值并塞入拓扑排序序列
    res.push(curr.val)
    // 从路径中移除当前节点，相当于回溯法中的撤销选择
    path.pop();
  }
```

题型参考：

1. `[210] 课程表 ii`
